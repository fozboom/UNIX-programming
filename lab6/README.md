# Лабораторная работа No 6. Работа с файлами, отображенными в память

Кооперация потоков для высокопроизводительной обработки больших файлов. Изучаемые системные вызовы: pthread_create(), pthread_exit(), pthread_join(), pthread_yield(), pthread_cancel(), pthread_barrier_init(), pthread_barrier_destroy(), pthread_barrier_wait(), mmap(), munmap().

### Задание
Написать многопоточную программу sort_index для сортировки вторичного индексного файла таблицы базы данных, работающую с файлом в двух режимах: read()/write() и с использованием отображение файлов в адресное пространство процесса. Программа должна запускаться следующим образом:
sort_index memsize granul threads filenаme

Параметры командной строки:
- memsize := размер рабочего буфера, кратный размеру страницы (getpagesize())
- blocks := порядок разбиения буфера
- threads := количество потоков (от k до N)
  - k := количество ядер
  - N := максимальное количество потоков (8k??)
- filenаme := имя файла

Количество блоков должно быть степенью двойки и превышать количество потоков.

Для целей тестирования написать программу генерации неотсортированного индексного файла.

### Алгоритм программы генерации
Генерируемый файл представляет собой вторичный индекс по времени и состоит из заголовка и индексных записей фиксированной длины.

Индексная запись имеет следующую структуру:
```c
struct index_s {
  double time_mark;     // временная метка (модифицированная юлианская дата)
  uint64_t recno;       // первичный индекс в таблице БД
} index_record;

```

Заголовок представляет собой следующую структуру

```c
struct index_hdr_s {
  uint64_t recsords;        // количество записей
  struct index_s idx[];     // массив записей в количестве records
}
```

Временная метка определяется в модифицированный юлианских днях. Целая часть лежит в пределах от 15020.0 (1900.01.01-0:0:0.0) до «вчера»6. Дробная – это часть дня (0.5 – 12:0:0.0). Для генерации целой и дробной частей временной метки используется системный генератор случайных чисел (random(3)).

Первичный индекс, как вариант, может заполняться последовательно, начиная с 1, но может быть случайным целым > 0 (в программе сортировки не используется).

Размер индекса в записях должен быть кратен 256 и кратно превышать планируемую выделенную память для отображения. Размер индекса и имя файла указывается при запуске программы генерации.


### Алгоритм программы сортировки

1. Основной поток запускает `threads` потоков, сообщая им адрес буфера, размер блока `memsize/blocks`, и их номер от 1 до `threads - 1`, используя возможность передачи аргумента для `start_routine`. Порожденные потоки останавливаются на барьере, ожидая прихода основного.
2. Основной поток c номером 0 открывает файл, отображает его часть размером `memsize` на память и синхронизируется на барьере. Барьер «открывается» и все `threads` потоков входят на равных в фазу сортировки.
3. Фаза сортировки: С каждым из блоков связана карта (массив) отсортированных блоков, в которой изначально блоки с 0 по `threads-1` отмечены, как занятые. Поток `n` начинает с того, что выбирает из массива блок со своим номером и его сортирует, используя `qsort(3)`. После того, как поток отсортировал свой первый блок, он на основе конкурентного захвата мьютекса, связанного с картой, получает к ней эксклюзивный доступ, отмечает следующий свободный блок, как занятый, освобождает мьютекс и приступает к его сортировке. Если свободных блоков нет, синхронизируется на барьере. После прохождения барьера все блоки будут отсортированы.
4. Фаза слияния: Поскольку блоков степень двойки, слияния производятся парами в цикле. Поток 0 сливает блоки 0 и1, поток 1 ‒ блоки 2 и 3, и так далее. Для отметки слитых пар и не слитых используется половина карты. Если для потока нет пары слияния, он синхронизируется на барьере. В результате слияния количество блоков, подлежащих слиянию сокращается в два раза, а размер их в два раза увеличивается. После очередного прохождения барьера количество блоков, подлежащих слиянию, станет меньше количества потоков. В этом случае распределение блоков между потоками осуществляется на основе конкурентного захвата мьютекса, связанного с картой. Потоки, котором не досталось блока, синхронизируются на барьере. Когда осталась последняя пара, все потоки с номером не равным нулю синхронизируются на барьере, о поток с номером 0 выполняет слияние последней пары. После слияния буфер становится отсортирован и подлежит сбросу в файл (`munmap()`). Если не весь файл обработан, продолжаем с шага 2).
5. Если весь файл обработан, основной поток отправляет запрос отмены порожденным потокам, выполняет слияние отсортированных частей файла и завершается.